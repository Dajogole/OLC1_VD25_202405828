package parser;

import java_cup.runtime.*;
import lexer.Lexer;
import ast.*;
import ast.expresiones.*;
import ast.sentencias.*;
import semantic.Tipo;
import reports.ErrorTipo;
import reports.TablaErrores;
import java.util.List;
import java.util.ArrayList;

action code {:
    // Código de acción para reportar errores
    public void report_error(String message, Object info) {
        System.err.println("Error sintáctico: " + message + " en línea " + 0 + ", columna " + 0);
    }

    public void report_fatal_error(String message, Object info) {
        System.err.println("Error sintáctico fatal: " + message + " en línea " + 0 + ", columna " + 0);
    }
:}

parser code {:
    // Código del parser
    private Programa programa;

    public Programa getPrograma() {
        return programa;
    }

    public void setPrograma(Programa p) {
        this.programa = p;
    }

    // --- Reporte de errores (dinámico) ---
    private TablaErrores tablaErrores;

    public void setTablaErrores(TablaErrores tablaErrores) {
        this.tablaErrores = tablaErrores;
    }

    @Override
    public void report_error(String message, Object info) {
        int linea = 0;
        int columna = 0;

        if (info instanceof java_cup.runtime.Symbol) {
            java_cup.runtime.Symbol s = (java_cup.runtime.Symbol) info;
            linea = s.left;
            columna = s.right;
        }

        if (tablaErrores != null) {
            tablaErrores.agregarError(ErrorTipo.SINTACTICO, message, linea, columna);
        } else {
            System.err.println("Error sintáctico: " + message + " en línea " + linea + ", columna " + columna);
        }
    }

    @Override
    public void report_fatal_error(String message, Object info) throws Exception {
        report_error(message, info);
        super.report_fatal_error(message, info);
    }
:}

/* ===========================
   TERMINALES (TOKENS)
   =========================== */

/* Fase 1 keywords */
terminal VAR, IF, ELSE, SWITCH, CASE, DEFAULT, WHILE, FOR, DO, BREAK, CONTINUE, PRINTLN;

/* Fase 2 keywords */
terminal VOID, RETURN, START;
terminal LIST, NEW, APPEND, REMOVE;

/* Native functions keywords */
terminal ROUND, LENGTH, TOSTRING, FIND, START_WITH;

/* Types */
terminal INT, DOUBLE, BOOL, CHAR, STRING;

/* Operators */
terminal PLUS, MINUS, MULTIPLY, DIVIDE, MODULO, POW;
terminal INCREMENT, DECREMENT;

/* Assignment and comparison */
terminal ASSIGN, EQ, NEQ, LT, GT, LE, GE;

/* Logical operators */
terminal AND, OR, NOT, XOR;

/* Grouping and punctuation */
terminal LPAREN, RPAREN, LBRACE, RBRACE, SEMICOLON, COLON, COMMA;
terminal LBRACKET, RBRACKET, DOT;

/* Literals (NO tocar) */
terminal Integer INTEGER_LITERAL;
terminal Double DOUBLE_LITERAL;
terminal Boolean BOOLEAN_LITERAL;
terminal Character CHAR_LITERAL;
terminal String STRING_LITERAL, IDENTIFIER;


/* ===========================
   NO TERMINALES
   =========================== */

non terminal Programa programa;
non terminal List<Sentencia> sentencias;
non terminal Sentencia sentencia;

non terminal DeclaracionVariable decl_var;
non terminal AsignacionVariable asign_var;

non terminal Expresion expresion;
non terminal Expresion valor;
non terminal Tipo tipo;
non terminal Tipo tipo_base;

non terminal BloqueSentencias bloque;
non terminal IfSentencia if_sentencia;
non terminal SwitchSentencia switch_sentencia;
non terminal List<Case> cases;
non terminal Case case_sent;
non terminal Default default_sent;
non terminal WhileSentencia while_sentencia;
non terminal ForSentencia for_sentencia;
non terminal DoWhileSentencia do_while_sentencia;
non terminal PrintlnSentencia println_sentencia;
non terminal BreakSentencia break_sentencia;
non terminal ContinueSentencia continue_sentencia;

non terminal Sentencia incremento;
non terminal Sentencia actualizacion_for;

non terminal ExpresionAritmetica expr_arit;
non terminal ExpresionRelacional expr_rel;
non terminal ExpresionLogica expr_log;
non terminal ExpresionCasteo expr_casteo;
non terminal ExpresionAgrupada expr_agrup;

/* --------- FASE 2: nuevos no-terminales (según tu lista) --------- */
non terminal DeclaracionFuncion decl_funcion;
non terminal List<Parametro> parametros_opt;
non terminal List<Parametro> parametros;
non terminal Parametro parametro;

non terminal List<Expresion> args_opt;
non terminal List<Expresion> args;

non terminal Expresion llamada_funcion;
non terminal Expresion llamada_miembro;
non terminal String nombre_funcion;
non terminal String nombre_metodo;

non terminal Expresion vector_literal;
non terminal Expresion matriz_literal;
non terminal List<Expresion> lista_valores_opt;
non terminal List<Expresion> lista_valores;
non terminal List<LiteralVector> filas_matriz;


/* ===========================
   PRECEDENCIA Y ASOCIATIVIDAD
   =========================== */

/* Operadores lógicos de menor a mayor prioridad */
precedence left OR;
precedence left XOR;
precedence left AND;

/* Comparaciones */
precedence left EQ, NEQ;
precedence left LT, GT, LE, GE;

/* Aritméticos */
precedence left PLUS, MINUS;
precedence left MULTIPLY, DIVIDE, MODULO;

/* Potencia: asociativa a la derecha */
precedence right POW;

/* Not lógico (unario) con mayor precedencia */
precedence right NOT;

/* Postfix (mayor prioridad) */
precedence left DOT;
precedence left LBRACKET;


/* ===========================
   REGLAS
   =========================== */

programa ::= sentencias:e
    {:
        setPrograma(new Programa(e, 0, 0));
        RESULT = programa;
    :}
    ;

sentencias ::= sentencias:s1 sentencia:s2
    {:
        List<Sentencia> lista = new ArrayList<Sentencia>();
        if (s1 != null) lista.addAll(s1);
        if (s2 != null) lista.add(s2);
        RESULT = lista;
    :}
    | /* vacío */
    {: RESULT = new ArrayList<Sentencia>(); :}
    ;


/* ===========================
   SENTENCIAS (REEMPLAZO COMPLETO)
   =========================== */

sentencia ::=
      decl_var:d SEMICOLON
        {: RESULT = d; :}

    /* Declaración tipada sin VAR: tipo id = valor; (ej: List<int> x = new List();) */
    | tipo:t IDENTIFIER:i ASSIGN valor:e SEMICOLON
    {: RESULT = new DeclaracionVariable(i, t, e, 0,0); :}

    /* Declaración List<T> id = new List(); */
    | LIST LT tipo_base:t GT IDENTIFIER:i ASSIGN NEW LIST LPAREN RPAREN SEMICOLON
        {: RESULT = new DeclaracionVariable(i, Tipo.listOf(t), new NuevaLista(t,0,0), 0,0); :}

    /* Asignación indexada vector/lista/matriz */
    | IDENTIFIER:i LBRACKET expresion:idx RBRACKET ASSIGN valor:val SEMICOLON
        {: RESULT = new AsignacionIndexada(new Identificador(i,0,0), idx, null, val, 0,0); :}
    | IDENTIFIER:i LBRACKET expresion:i1 RBRACKET LBRACKET expresion:i2 RBRACKET ASSIGN valor:val SEMICOLON
        {: RESULT = new AsignacionIndexada(new Identificador(i,0,0), i1, i2, val, 0,0); :}

    /* ++ y -- como sentencia (id o indexado) */
    | IDENTIFIER:i INCREMENT SEMICOLON
        {: RESULT = new IncDecSentencia(new Identificador(i,0,0), true, 0,0); :}
    | IDENTIFIER:i DECREMENT SEMICOLON
        {: RESULT = new IncDecSentencia(new Identificador(i,0,0), false, 0,0); :}
    | IDENTIFIER:i LBRACKET expresion:idx RBRACKET INCREMENT SEMICOLON
        {: RESULT = new IncDecSentencia(new AccesoIndexado(new Identificador(i,0,0), idx, null,0,0), true,0,0); :}
    | IDENTIFIER:i LBRACKET expresion:idx RBRACKET DECREMENT SEMICOLON
        {: RESULT = new IncDecSentencia(new AccesoIndexado(new Identificador(i,0,0), idx, null,0,0), false,0,0); :}

    /* return; y return valor; */
    | RETURN SEMICOLON
        {: RESULT = new ReturnSentencia(null,0,0); :}
    | RETURN valor:e SEMICOLON
        {: RESULT = new ReturnSentencia(e,0,0); :}

    /* start id(); / start id(args); */
    | START IDENTIFIER:i LPAREN args_opt:a RPAREN SEMICOLON
        {: RESULT = new StartSentencia(i,a,0,0); :}

    /* Declaración funciones y métodos */
    | decl_funcion:f
        {: RESULT = f; :}

    /* Llamadas como sentencia (función o método/miembro) */
    | llamada_funcion:lf SEMICOLON
        {: RESULT = new SentenciaExpresion(lf,0,0); :}
    | llamada_miembro:lm SEMICOLON
        {: RESULT = new SentenciaExpresion(lm,0,0); :}

    /* Fase 1 intacto */
    | asign_var:a SEMICOLON
        {: RESULT = a; :}
    | if_sentencia:i
        {: RESULT = i; :}
    | switch_sentencia:s
        {: RESULT = s; :}
    | while_sentencia:w
        {: RESULT = w; :}
    | for_sentencia:f
        {: RESULT = f; :}
    | do_while_sentencia:d
        {: RESULT = d; :}
    | break_sentencia:b SEMICOLON
        {: RESULT = b; :}
    | continue_sentencia:c SEMICOLON
        {: RESULT = c; :}
    | println_sentencia:p SEMICOLON
        {: RESULT = p; :}
    | bloque:b
        {: RESULT = b; :}
    ;

bloque ::= LBRACE sentencias:s RBRACE
    {: RESULT = new BloqueSentencias(s, 0, 0); :}
    ;

decl_var ::= VAR IDENTIFIER:i COLON tipo:t
    {: RESULT = new DeclaracionVariable(i, t, null, 0, 0); :}
    | VAR IDENTIFIER:i COLON tipo:t ASSIGN valor:e
    {: RESULT = new DeclaracionVariable(i, t, e, 0, 0); :}

    /* Recuperación específica: falta ':' */
    | VAR IDENTIFIER:i tipo:t
    {:
        if (tablaErrores != null) {
            tablaErrores.agregarError(
                ErrorTipo.SINTACTICO,
                "No se esperaba el componente " + t.toString(),
                tleft,
                tright
            );
        }
        RESULT = new DeclaracionVariable(i, t, null, 0, 0);
    :}
    | VAR IDENTIFIER:i tipo:t ASSIGN valor:e
    {:
        if (tablaErrores != null) {
            tablaErrores.agregarError(
                ErrorTipo.SINTACTICO,
                "No se esperaba el componente " + t.toString(),
                tleft,
                tright
            );
        }
        RESULT = new DeclaracionVariable(i, t, e, 0, 0);
    :}
    ;


/* ===========================
   TIPOS (Fase 2)
   =========================== */

tipo ::= tipo_base:t
        {: RESULT = t; :}
      | tipo_base:t LBRACKET RBRACKET
        {: RESULT = Tipo.vectorOf(t); :}
      | tipo_base:t LBRACKET RBRACKET LBRACKET RBRACKET
        {: RESULT = Tipo.matrixOf(t); :}
      | LIST LT tipo_base:t GT
        {: RESULT = Tipo.listOf(t); :}
      ;

tipo_base ::= INT    {: RESULT = Tipo.INT; :}
           | DOUBLE {: RESULT = Tipo.DOUBLE; :}
           | BOOL   {: RESULT = Tipo.BOOL; :}
           | CHAR   {: RESULT = Tipo.CHAR; :}
           | STRING {: RESULT = Tipo.STRING; :}
           ;

asign_var ::= IDENTIFIER:i ASSIGN valor:e
    {: RESULT = new AsignacionVariable(i, e, ileft, iright); :}
    ;


/* ===========================
   VALORES (permite literales de vector/matriz solo donde tienen sentido)
   =========================== */
valor ::= expresion:e
    {: RESULT = e; :}
    | vector_literal:v
    {: RESULT = v; :}
    | matriz_literal:m
    {: RESULT = m; :}
    ;


/* ===========================
   EXPRESIONES
   =========================== */

expresion ::= IDENTIFIER:i
    {: RESULT = new Identificador(i, ileft, iright); :}
    | INTEGER_LITERAL:i
    {: RESULT = new LiteralEntero(i, ileft, iright); :}
    | DOUBLE_LITERAL:d
    {: RESULT = new LiteralDouble(d, dleft, dright); :}
    | BOOLEAN_LITERAL:b
    {: RESULT = new LiteralBooleano(b, bleft, bright); :}
    | CHAR_LITERAL:c
    {: RESULT = new LiteralChar(c, cleft, cright); :}
    | STRING_LITERAL:s
    {: RESULT = new LiteralString(s, sleft, sright); :}

    | expr_arit:e {: RESULT = e; :}
    | expr_rel:e  {: RESULT = e; :}
    | expr_log:e  {: RESULT = e; :}
    | expr_casteo:e {: RESULT = e; :}
    | expr_agrup:e {: RESULT = e; :}

    /* --------- J) NUEVAS EXPRESIONES FASE 2 --------- */
    | llamada_miembro:lm
        {: RESULT = lm; :}
    | llamada_funcion:lf
        {: RESULT = lf; :}

    | NEW LIST LT tipo_base:t GT LPAREN RPAREN
        {: RESULT = new NuevaLista(t,0,0); :}
    | NEW LIST LPAREN RPAREN
        {: RESULT = new NuevaLista(Tipo.ERROR,0,0); :}

    | expresion:e LBRACKET expresion:i RBRACKET
        {: RESULT = new AccesoIndexado(e,i,null,0,0); :}
        %prec LBRACKET
    | expresion:e LBRACKET expresion:i RBRACKET LBRACKET expresion:j RBRACKET
        {: RESULT = new AccesoIndexado(e,i,j,0,0); :}
        %prec LBRACKET
    ;

expr_arit ::= expresion:e1 PLUS:p expresion:e2
    {: RESULT = new ExpresionAritmetica(e1, e2, OperadorAritmetico.SUMA, pleft, pright); :}
    | expresion:e1 MINUS:m expresion:e2
    {: RESULT = new ExpresionAritmetica(e1, e2, OperadorAritmetico.RESTA, mleft, mright); :}
    | expresion:e1 MULTIPLY:mul expresion:e2
    {: RESULT = new ExpresionAritmetica(e1, e2, OperadorAritmetico.MULTIPLICACION, mulleft, mulright); :}
    | expresion:e1 DIVIDE:div expresion:e2
    {: RESULT = new ExpresionAritmetica(e1, e2, OperadorAritmetico.DIVISION, divleft, divright); :}
    | expresion:e1 MODULO:mod expresion:e2
    {: RESULT = new ExpresionAritmetica(e1, e2, OperadorAritmetico.MODULO, modleft, modright); :}
    | expresion:e1 POW:pow expresion:e2
    {: RESULT = new ExpresionAritmetica(e1, e2, OperadorAritmetico.POTENCIA, powleft, powright); :}
    | MINUS:m expresion:e
    {: RESULT = new ExpresionAritmetica(null, e, OperadorAritmetico.NEGACION_UNARIA, mleft, mright); :}
    ;

expr_rel ::= expresion:e1 LT:op expresion:e2
    {: RESULT = new ExpresionRelacional(e1, e2, OperadorRelacional.MENOR, opleft, opright); :}
    | expresion:e1 GT:op expresion:e2
    {: RESULT = new ExpresionRelacional(e1, e2, OperadorRelacional.MAYOR, opleft, opright); :}
    | expresion:e1 LE:op expresion:e2
    {: RESULT = new ExpresionRelacional(e1, e2, OperadorRelacional.MENOR_IGUAL, opleft, opright); :}
    | expresion:e1 GE:op expresion:e2
    {: RESULT = new ExpresionRelacional(e1, e2, OperadorRelacional.MAYOR_IGUAL, opleft, opright); :}
    | expresion:e1 EQ:op expresion:e2
    {: RESULT = new ExpresionRelacional(e1, e2, OperadorRelacional.IGUAL, opleft, opright); :}
    | expresion:e1 NEQ:op expresion:e2
    {: RESULT = new ExpresionRelacional(e1, e2, OperadorRelacional.DIFERENTE, opleft, opright); :}
    ;

expr_log ::= expresion:e1 AND:op expresion:e2
    {: RESULT = new ExpresionLogica(e1, e2, OperadorLogico.AND, opleft, opright); :}
    | expresion:e1 OR:op expresion:e2
    {: RESULT = new ExpresionLogica(e1, e2, OperadorLogico.OR, opleft, opright); :}
    | expresion:e1 XOR:op expresion:e2
    {: RESULT = new ExpresionLogica(e1, e2, OperadorLogico.XOR, opleft, opright); :}
    | NOT:op expresion:e
    {: RESULT = new ExpresionLogica(null, e, OperadorLogico.NOT, opleft, opright); :}
    ;

expr_casteo ::= LPAREN tipo:t RPAREN expresion:e
    {: RESULT = new ExpresionCasteo(t, e, 0, 0); :}
    ;

expr_agrup ::= LPAREN expresion:e RPAREN
    {: RESULT = new ExpresionAgrupada(e, 0, 0); :}
    ;


/* ===========================
   ESTRUCTURAS DE CONTROL F1
   =========================== */

if_sentencia ::= IF LPAREN expresion:e RPAREN bloque:b
    {: RESULT = new IfSentencia(e, b, null, null, 0, 0); :}
    | IF LPAREN expresion:e RPAREN bloque:b1 ELSE bloque:b2
    {: RESULT = new IfSentencia(e, b1, b2, null, 0, 0); :}
    | IF LPAREN expresion:e RPAREN bloque:b1 ELSE if_sentencia:i
    {: RESULT = new IfSentencia(e, b1, null, i, 0, 0); :}
    ;

switch_sentencia ::= SWITCH LPAREN expresion:e RPAREN LBRACE cases:c RBRACE
    {: RESULT = new SwitchSentencia(e, c, null, 0, 0); :}
    | SWITCH LPAREN expresion:e RPAREN LBRACE cases:c default_sent:d RBRACE
    {: RESULT = new SwitchSentencia(e, c, d, 0, 0); :}
    | SWITCH LPAREN expresion:e RPAREN LBRACE default_sent:d RBRACE
    {: RESULT = new SwitchSentencia(e, null, d, 0, 0); :}
    ;

cases ::= cases:c1 case_sent:c2
    {:
        List<Case> lista = new ArrayList<Case>();
        if (c1 != null) lista.addAll(c1);
        if (c2 != null) lista.add(c2);
        RESULT = lista;
    :}
    | case_sent:c
    {:
        List<Case> lista = new ArrayList<Case>();
        if (c != null) lista.add(c);
        RESULT = lista;
    :}
    ;

case_sent ::= CASE expresion:e COLON sentencias:s
    {: RESULT = new Case(e, s, 0, 0); :}
    ;

default_sent ::= DEFAULT COLON sentencias:s
    {: RESULT = new Default(s, 0, 0); :}
    ;

while_sentencia ::= WHILE LPAREN expresion:e RPAREN bloque:b
    {: RESULT = new WhileSentencia(e, b, 0, 0); :}
    ;


/* FOR: actualización puede ser asignación o incremento (i++ / i--) */
for_sentencia ::= FOR LPAREN asign_var:a1 SEMICOLON expresion:e SEMICOLON actualizacion_for:a2 RPAREN bloque:b
    {: RESULT = new ForSentencia(a1, e, a2, b, 0, 0); :}
    | FOR LPAREN decl_var:d SEMICOLON expresion:e SEMICOLON actualizacion_for:a RPAREN bloque:b
    {: RESULT = new ForSentencia(d, e, a, b, 0, 0); :}
    ;

actualizacion_for ::= asign_var:a
    {: RESULT = a; :}
    | incremento:i
    {: RESULT = i; :}
    ;

/* Incremento/decremento para el FOR (devuelve AsignacionVariable) */
incremento ::= IDENTIFIER:i INCREMENT
    {:
        Expresion inc = new ExpresionAritmetica(
            new Identificador(i, 0, 0),
            new LiteralEntero(1, 0, 0),
            OperadorAritmetico.SUMA,
            0, 0
        );
        RESULT = new AsignacionVariable(i, inc, 0, 0);
    :}
    | IDENTIFIER:i DECREMENT
    {:
        Expresion dec = new ExpresionAritmetica(
            new Identificador(i, 0, 0),
            new LiteralEntero(1, 0, 0),
            OperadorAritmetico.RESTA,
            0, 0
        );
        RESULT = new AsignacionVariable(i, dec, 0, 0);
    :}
    ;

do_while_sentencia ::= DO bloque:b WHILE LPAREN expresion:e RPAREN SEMICOLON
    {: RESULT = new DoWhileSentencia(b, e, 0, 0); :}
    ;

println_sentencia ::= PRINTLN LPAREN valor:e RPAREN
    {: RESULT = new PrintlnSentencia(e, 0, 0); :}
    ;

break_sentencia ::= BREAK
    {: RESULT = new BreakSentencia(0, 0); :}
    ;

continue_sentencia ::= CONTINUE
    {: RESULT = new ContinueSentencia(0, 0); :}
    ;


/* ===========================
   F) Declaración de funciones / métodos
   =========================== */

decl_funcion ::=
      VOID IDENTIFIER:n LPAREN parametros_opt:p RPAREN bloque:b
        {: RESULT = new DeclaracionFuncion(Tipo.VOID, n, p, b, 0,0); :}
    | tipo:t IDENTIFIER:n LPAREN parametros_opt:p RPAREN bloque:b
        {: RESULT = new DeclaracionFuncion(t, n, p, b, 0,0); :}
    ;


parametros_opt ::= parametros:p
    {: RESULT = p; :}
    | /* empty */
    {: RESULT = new ArrayList<Parametro>(); :}
    ;

parametros ::= parametros:p COMMA parametro:q
    {: p.add(q); RESULT = p; :}
    | parametro:q
    {:
        List<Parametro> l = new ArrayList<Parametro>();
        l.add(q);
        RESULT = l;
    :}
    ;

parametro ::= tipo:t IDENTIFIER:n
    {: RESULT = new Parametro(n, t, 0,0); :}
    ;


/* ===========================
   G) Argumentos + nombres reservados como funciones
   =========================== */

args_opt ::= args:a
    {: RESULT = a; :}
    | /* empty */
    {: RESULT = new ArrayList<Expresion>(); :}
    ;

args ::= args:a COMMA valor:e
    {: a.add(e); RESULT = a; :}
    | valor:e
    {:
        List<Expresion> l = new ArrayList<Expresion>();
        l.add(e);
        RESULT = l;
    :}
    ;

nombre_funcion ::= IDENTIFIER:i
    {: RESULT = i; :}
    | ROUND
    {: RESULT = "round"; :}
    | LENGTH
    {: RESULT = "length"; :}
    | TOSTRING
    {: RESULT = "toString"; :}
    | FIND
    {: RESULT = "find"; :}
    | START_WITH
    {: RESULT = "START_WITH"; :}
    ;

llamada_funcion ::= nombre_funcion:n LPAREN args_opt:a RPAREN
    {: RESULT = new LlamadaFuncion(n, a, 0,0); :}
    ;


/* ===========================
   H) Métodos (miLista.append / remove / find / START_WITH)
   =========================== */

nombre_metodo ::= IDENTIFIER:i
    {: RESULT = i; :}
    | APPEND
    {: RESULT = "append"; :}
    | REMOVE
    {: RESULT = "remove"; :}
    | FIND
    {: RESULT = "find"; :}
    | START_WITH
    {: RESULT = "START_WITH"; :}
    ;

llamada_miembro ::= expresion:obj DOT nombre_metodo:m LPAREN args_opt:a RPAREN
    {: RESULT = new LlamadaMiembro(obj, m, a, 0,0); :}
    ;


/* ===========================
   I) Literales de vector/matriz
   =========================== */

vector_literal ::= LBRACKET lista_valores_opt:l RBRACKET
    {: RESULT = new LiteralVector(l,0,0); :}
    ;

lista_valores_opt ::= lista_valores:l
    {: RESULT = l; :}
    | /* empty */
    {: RESULT = new ArrayList<Expresion>(); :}
    ;

lista_valores ::= lista_valores:l COMMA expresion:e
    {: l.add(e); RESULT = l; :}
    | expresion:e
    {:
        List<Expresion> l = new ArrayList<Expresion>();
        l.add(e);
        RESULT = l;
    :}
    ;

/* Matriz literal (NO vacía): [[1,2],[3,4]] */
filas_matriz ::= filas_matriz:f COMMA vector_literal:r
    {: f.add((LiteralVector) r); RESULT = f; :}
    | vector_literal:r
    {:
        List<LiteralVector> f = new ArrayList<LiteralVector>();
        f.add((LiteralVector) r);
        RESULT = f;
    :}
    ;

matriz_literal ::= LBRACKET filas_matriz:f RBRACKET
    {: RESULT = new LiteralMatriz(f,0,0); :}
    ;
